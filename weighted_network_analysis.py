# -*- coding: utf-8 -*-
"""Weighted Network Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gyFBz49Jw-Bo2a8K8teLR_nJyzS3V814
"""

import geopandas as gpd
import pandas as pd
import numpy as np
import networkx as nx
import json
import matplotlib.pyplot as plt
import folium
from itertools import combinations
from shapely.geometry import LineString
from shapely.geometry import Point, MultiPoint
from shapely.ops import unary_union, linemerge

from google.colab import drive
drive.mount('/content/drive/')

# Load GeoJSON file
gdf = gpd.read_file('/content/drive/MyDrive/C257 Project/Data/WeightedNetwork2.json')

gdf

"""# **1. Buid Weighted Network**"""

gdf = gdf.set_crs("EPSG:4326", allow_override=True)  # Set the CRS to WGS84

# Project the entire GeoDataFrame to the California zone 3 (meters)
gdf_projected = gdf.to_crs("EPSG:26943")

# Check the total bounds after projection
print(gdf_projected.total_bounds)

# Extract the x and y coordinates of the projected geometries
x_coords = [geom.xy[0][0] for geom in gdf_projected.geometry if geom is not None and not geom.is_empty]
y_coords = [geom.xy[1][0] for geom in gdf_projected.geometry if geom is not None and not geom.is_empty]

# Check for any infinite values among the x and y coordinates
inf_x = np.isinf(x_coords).sum()
inf_y = np.isinf(y_coords).sum()

print(f"Infinite x coordinates: {inf_x}")
print(f"Infinite y coordinates: {inf_y}")

# Remove duplicates (based on geometry or other attributes)
gdf_projected = gdf_projected.drop_duplicates(subset=['geometry'])

intersections = gpd.GeoDataFrame(columns=['geometry'], crs=gdf_projected.crs)
intersections = intersections.set_geometry('geometry')

# Identify Intersections (Nodes)
for road1, road2 in combinations(gdf_projected.geometry, 2):
    if road1.intersects(road2):
        intersection = road1.intersection(road2)
        if isinstance(intersection, Point):
            intersection_df = gpd.GeoDataFrame({'geometry': [intersection]}, crs=gdf_projected.crs)
            intersections = pd.concat([intersections, intersection_df], ignore_index=True)

# Remove duplicate intersections
intersections = intersections.drop_duplicates(subset=['geometry'])

# Assign IDs to intersections
intersections['id'] = range(len(intersections))

# Print the CRS of the intersections GeoDataFrame
print("CRS of intersections:", intersections.crs)

# Print the CRS of the projected GeoDataFrame
print("CRS of gdf_projected:", gdf_projected.crs)

intersections

gdf_projected

# Initialize an empty DataFrame for edges
edges_df = pd.DataFrame(columns=['start_node', 'end_node', 'attributes'])

# Assign Weights and Create Edges
for index, road in gdf_projected.iterrows():
    start_node = end_node = None
    for idx, node in intersections.iterrows():
        if road.geometry.touches(node.geometry):
            if start_node is None:
                start_node = node['id']
            else:
                end_node = node['id']
                break
    if start_node is not None and end_node is not None:
        # Pack weight and geometry into a dictionary
        attributes = {'weight': road['Allweight'], 'geometry': road.geometry}
        # Create a temporary DataFrame for the current edge
        temp_df = pd.DataFrame({'start_node': [start_node],
                                'end_node': [end_node],
                                'attributes': [attributes]})
        # Concatenate with the main edges DataFrame
        edges_df = pd.concat([edges_df, temp_df], ignore_index=True)

# Convert DataFrame to a list of tuples for NetworkX
edges_list = list(edges_df.itertuples(index=False, name=None))

# Create Graph
G = nx.Graph()
G.add_edges_from(edges_list)

print("Number of Links in random network: ",G.number_of_edges())
print("Number of nodes in acquaintance network: ",G.number_of_nodes())

"""# **2. Visualization**"""

# Initialize a dictionary to store node positions
pos = {}

# Loop through each edge to infer node positions
for u, v, data in G.edges(data=True):
    if 'geometry' in data:
        # Assuming each edge has a geometry attribute
        line = data['geometry']
        # Use the start and end points of the line as node positions
        pos[u] = (line.coords[0][0], line.coords[0][1])  # Start point
        pos[v] = (line.coords[-1][0], line.coords[-1][1])  # End point

# Draw the network
plt.figure(figsize=(12, 8))
nx.draw_networkx_nodes(G, pos, node_size=10, node_color="blue")

plt.title("Visualization of the Road Network")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

# Adjust node size and edge width based on weight
node_size = 10  # Smaller node size
# Normalize the edge widths if necessary
edge_widths = [data['weight'] for _, _, data in G.edges(data=True)]
max_width = max(edge_widths)
edge_widths = [w / max_width * 5 for w in edge_widths]  # Adjust scaling factor as needed

# Draw the network
plt.figure(figsize=(12, 8))
nx.draw_networkx_nodes(G, pos, node_size=node_size, node_color="blue")
nx.draw_networkx_edges(G, pos, width=edge_widths, alpha=0.5, edge_color='green')

plt.title("Visualization of the Road Network in San Francisco")
plt.xlabel("Projected Coordinate X (meters)")
plt.ylabel("Projected Coordinate Y (meters)")
plt.axis("equal")  # This ensures that one unit in x is the same as one unit in y
plt.show()

plt.figure(figsize=(12, 8))
nx.draw_networkx_nodes(G, pos, node_size=node_size, node_color="blue")

plt.title("Visualization of the Road Network Nodes in San Francisco")
plt.xlabel("Projected Coordinate X (meters)")
plt.ylabel("Projected Coordinate Y (meters)")
plt.axis("equal")  # This ensures that one unit in x is the same as one unit in y
plt.show()

"""# **3. Analysis Network**"""

# Assuming G is your road network graph

# 1. Analysis of current connectivity
# Compute the largest connected component
largest_cc = max(nx.connected_components(G), key=len)
subgraph = G.subgraph(largest_cc)

# Calculate average shortest path length in the largest connected component
avg_shortest_path_length = nx.average_shortest_path_length(subgraph)
print(f"Average shortest path length: {avg_shortest_path_length}")

# Compute the number of connected components
num_connected_components = nx.number_connected_components(G)
print(f"Number of connected components: {num_connected_components}")

# Compute node connectivity of the largest connected component
node_connectivity = nx.node_connectivity(subgraph)
print(f"Node connectivity: {node_connectivity}")

# 2. Identify weak connectivity
# Find bridges
bridges = list(nx.bridges(subgraph))
print(f"Bridges: {bridges}")

# Compute betweenness centrality
betweenness = nx.betweenness_centrality(subgraph)
# Sort nodes by betweenness centrality
sorted_betweenness = sorted(betweenness.items(), key=lambda item: item[1], reverse=True)
print(f"Top nodes by betweenness centrality: {sorted_betweenness[:5]}")

# Find edges with high betweenness centrality
edge_betweenness = nx.edge_betweenness_centrality(subgraph)
sorted_edge_betweenness = sorted(edge_betweenness.items(), key=lambda item: item[1], reverse=True)
print(f"Top edges by betweenness centrality: {sorted_edge_betweenness[:5]}")

# Draw the network
plt.figure(figsize=(12, 8))

# Draw all nodes
nx.draw_networkx_nodes(G, pos, node_size=10, node_color="blue", alpha=0.5)

# Draw all edges
nx.draw_networkx_edges(G, pos, alpha=0.5, edge_color='grey')

# Highlight the bridges in the graph with red color
bridge_edges = [(u, v) for u, v in bridges]
nx.draw_networkx_edges(G, pos, edgelist=bridge_edges, edge_color='red', alpha=0.8, width=2)

plt.title("Visualization of the Road Network with Bridges Highlighted")
plt.xlabel("Projected Coordinate X (meters)")
plt.ylabel("Projected Coordinate Y (meters)")
plt.axis('equal')  # Turn off the axis
plt.show()

"""Incorporating weights into the analysis to improve connectivity can be approached by considering the suitability of each road for active travel. If a higher weight indicates better suitability, then you would want to prioritize improving roads with lower weights, as these are less suitable in their current state. However, simply improving the least suitable roads doesn't ensure maximum connectivity; you also want to improve roads that would most benefit the overall connectivity of the network.

Here's a strategy using NetworkX:

1-Calculate Betweenness Centrality: This metric identifies the most critical roads in terms of the number of shortest paths that pass through them. Improving these roads can have a significant impact on the efficiency of the network.

2-Inverse Weight as a Measure for Improvement: Since higher weights indicate better roads, you can use the inverse of the weight to determine which roads need improvement the most.

3-Combine the Metrics: Create a composite metric that combines both the betweenness centrality and the inverse of the weight to prioritize which roads to improve.

Sort: Betweenness Centrality + Inverse Weight

Limit: Length (Meter)
"""

# Iterate over edges to calculate length if it's not already present
for u, v, data in G.edges(data=True):
    if 'length' not in data:
        # Calculate the length from the geometry attribute
        line = data['geometry']
        # Assuming that the geometry is in a projected coordinate system where length is in meters
        data['length'] = line.length

# Now, let's print one edge to verify the length has been added
for u, v, data in G.edges(data=True):
    print(f"Edge from {u} to {v} with attributes {data}")

import networkx as nx

# Calculate betweenness centrality for edges
edge_betweenness = nx.edge_betweenness_centrality(G, weight='weight')

# Create a dictionary to hold potential improvement score for each edge
improvement_scores = {}

# Calculate improvement score for each edge
for edge in G.edges(data=True):
    # Use the inverse of the weight so that lower weights (less suitable) have higher priority for improvement
    weight = edge[2]['weight']
    inv_weight = 1.0 / weight if weight != 0 else 0

    # Combine betweenness centrality and inverse weight
    improvement_score = edge_betweenness[(edge[0], edge[1])] * inv_weight
    improvement_scores[(edge[0], edge[1])] = improvement_score

# Sort edges by improvement score
edges_sorted_by_improvement = sorted(improvement_scores.items(), key=lambda item: item[1], reverse=True)

# Let's say you have a budget to improve a certain length of road
budget_length = 11788  # Example length in meters

# Select edges to improve
edges_to_improve = []
length_improved = 0

for edge, score in edges_sorted_by_improvement:
    # Assume we have a way to determine the length of each edge, for example using a 'length' attribute
    edge_length = G[edge[0]][edge[1]]['length']

    # Check if we can include this edge within our budget
    if length_improved + edge_length <= budget_length:
        edges_to_improve.append(edge)
        length_improved += edge_length
    else:
        break

# Output the selected edges for improvement
print("Edges selected for improvement:", edges_to_improve)

import matplotlib.pyplot as plt
import networkx as nx

# Assuming 'G' is your road network graph, 'pos' contains the positions of the nodes, and 'edges_to_improve' is a list of edges

# Draw the network
plt.figure(figsize=(12, 8))

# Draw all edges
nx.draw_networkx_edges(G, pos, alpha=0.5, edge_color='000000')

# Draw all nodes
nx.draw_networkx_nodes(G, pos, node_size=10, node_color='#fd2e98', alpha=0.5)

# Highlight the edges to improve in red color
nx.draw_networkx_edges(G, pos, edgelist=edges_to_improve, edge_color='blue', width=3,alpha=0.5)

plt.title("Road Network with Edges to Improve Highlighted")
plt.xlabel("Projected Coordinate X (meters)")
plt.ylabel("Projected Coordinate Y (meters)")
plt.axis('equal')
plt.show()

