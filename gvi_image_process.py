# -*- coding: utf-8 -*-
"""GVI_Image_Process.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fzU7hev5xevOjaBEklFbASxGIJG6Jp7d
"""

pip install pymeanshift

import pymeanshift as pms
import numpy as np
import requests
import geopandas as gpd
import csv
import os
import numpy as np
import requests
from PIL import Image
from io import BytesIO

def graythresh(array,level):
    '''array: is the numpy array waiting for processing
    return thresh: is the result got by OTSU algorithm
    if the threshold is less than level, then set the level as the threshold
    by Xiaojiang Li
    '''

    import numpy as np

    maxVal = np.max(array)
    minVal = np.min(array)

#   if the inputImage is a float of double dataset then we transform the data
#   in to byte and range from [0 255]
    if maxVal <= 1:
        array = array*255
        # print "New max value is %s" %(np.max(array))
    elif maxVal >= 256:
        array = np.int((array - minVal)/(maxVal - minVal))
        # print "New min value is %s" %(np.min(array))

    # turn the negative to natural number
    negIdx = np.where(array < 0)
    array[negIdx] = 0

    # calculate the hist of 'array'
    dims = np.shape(array)
    hist = np.histogram(array,range(257))
    P_hist = hist[0]*1.0/np.sum(hist[0])

    omega = P_hist.cumsum()

    temp = np.arange(256)
    mu = P_hist*(temp+1)
    mu = mu.cumsum()

    n = len(mu)
    mu_t = mu[n-1]

    sigma_b_squared = (mu_t*omega - mu)**2/(omega*(1-omega))

    # try to found if all sigma_b squrered are NaN or Infinity
    indInf = np.where(sigma_b_squared == np.inf)

    CIN = 0
    if len(indInf[0])>0:
        CIN = len(indInf[0])

    maxval = np.max(sigma_b_squared)

    IsAllInf = CIN == 256
    if IsAllInf !=1:
        index = np.where(sigma_b_squared==maxval)
        idx = np.mean(index)
        threshold = (idx - 1)/255.0
    else:
        threshold = level

    if np.isnan(threshold):
        threshold = level

    return threshold

def VegetationClassificationToMask(Img):
    '''
    This function is used to classify the green vegetation from GSV image,
    This is based on object based and otsu automatically thresholding method
    The season of GSV images were also considered in this function
        Img: the numpy array image, eg. Img = np.array(Image.open(StringIO(response.content)))
        return the percentage of the green vegetation pixels in the GSV image

    By Xiaojiang Li
    '''

    import pymeanshift as pms
    import numpy as np

    # use the meanshift segmentation algorithm to segment the original GSV image
    (segmented_image, labels_image, number_regions) = pms.segment(Img,spatial_radius=6,
                                                     range_radius=7, min_density=40)

    I = segmented_image/255.0

    red = I[:,:,0]
    green = I[:,:,1]
    blue = I[:,:,2]

    # calculate the difference between green band with other two bands
    green_red_Diff = green - red
    green_blue_Diff = green - blue

    ExG = green_red_Diff + green_blue_Diff
    diffImg = green_red_Diff*green_blue_Diff

    redThreImgU = red < 0.6
    greenThreImgU = green < 0.9
    blueThreImgU = blue < 0.6

    shadowRedU = red < 0.3
    shadowGreenU = green < 0.3
    shadowBlueU = blue < 0.3
    del red, blue, green, I

    greenImg1 = redThreImgU * blueThreImgU*greenThreImgU
    greenImgShadow1 = shadowRedU*shadowGreenU*shadowBlueU
    del redThreImgU, greenThreImgU, blueThreImgU
    del shadowRedU, shadowGreenU, shadowBlueU

    greenImg3 = diffImg > 0.0
    greenImg4 = green_red_Diff > 0
    threshold = graythresh(ExG, 0.1)

    if threshold > 0.1:
        threshold = 0.1
    elif threshold < 0.05:
        threshold = 0.05

    greenImg2 = ExG > threshold
    greenImgShadow2 = ExG > 0.05
    greenImg = greenImg1*greenImg2 + greenImgShadow2*greenImgShadow1
    del ExG,green_blue_Diff,green_red_Diff
    del greenImgShadow1,greenImgShadow2

    # calculate the percentage of the green vegetation
    greenPxlNum = len(np.where(greenImg != 0)[0])
    greenPercent = greenPxlNum/(400.0*400)*100
    del greenImg1,greenImg2
    del greenImg3,greenImg4
    bw_mask = np.where(greenImg != 0, 255, 0).astype(np.uint8)
    return bw_mask

def VegetationClassification(Img):
    '''
    This function is used to classify the green vegetation from GSV image,
    This is based on object based and otsu automatically thresholding method
    The season of GSV images were also considered in this function
        Img: the numpy array image, eg. Img = np.array(Image.open(StringIO(response.content)))
        return the percentage of the green vegetation pixels in the GSV image

    By Xiaojiang Li
    '''

    import pymeanshift as pms
    import numpy as np

    # use the meanshift segmentation algorithm to segment the original GSV image
    (segmented_image, labels_image, number_regions) = pms.segment(Img,spatial_radius=6,
                                                     range_radius=7, min_density=40)

    I = segmented_image/255.0

    red = I[:,:,0]
    green = I[:,:,1]
    blue = I[:,:,2]

    # calculate the difference between green band with other two bands
    green_red_Diff = green - red
    green_blue_Diff = green - blue

    ExG = green_red_Diff + green_blue_Diff
    diffImg = green_red_Diff*green_blue_Diff

    redThreImgU = red < 0.6
    greenThreImgU = green < 0.9
    blueThreImgU = blue < 0.6

    shadowRedU = red < 0.3
    shadowGreenU = green < 0.3
    shadowBlueU = blue < 0.3
    del red, blue, green, I

    greenImg1 = redThreImgU * blueThreImgU*greenThreImgU
    greenImgShadow1 = shadowRedU*shadowGreenU*shadowBlueU
    del redThreImgU, greenThreImgU, blueThreImgU
    del shadowRedU, shadowGreenU, shadowBlueU

    greenImg3 = diffImg > 0.0
    greenImg4 = green_red_Diff > 0
    threshold = graythresh(ExG, 0.1)

    if threshold > 0.1:
        threshold = 0.1
    elif threshold < 0.05:
        threshold = 0.05

    greenImg2 = ExG > threshold
    greenImgShadow2 = ExG > 0.05
    greenImg = greenImg1*greenImg2 + greenImgShadow2*greenImgShadow1
    del ExG,green_blue_Diff,green_red_Diff
    del greenImgShadow1,greenImgShadow2

    # calculate the percentage of the green vegetation
    greenPxlNum = len(np.where(greenImg != 0)[0])
    greenPercent = greenPxlNum/(400.0*400)*100
    del greenImg1,greenImg2
    del greenImg3,greenImg4

    return greenPercent

def get_session_token(api_key):
    session_url = "https://tile.googleapis.com/v1/createSession"
    headers = {'Content-Type': 'application/json'}
    params = {'key': api_key}
    body = {
        "mapType": "streetview",
        "language": "en-US",
        "region": "US"
    }

    response = requests.post(session_url, headers=headers, json=body, params=params)
    response.raise_for_status()  # This will raise an exception for HTTP errors

    json_response = response.json()
    if 'session' in json_response:
        return json_response['session']
    else:
        raise ValueError("JSON response does not contain 'session'")

# Use your actual API key here
api_key = 'AIzaSyC6SI5E0xZd2txN1gUtGo52CYKpOlXBRSU'
session_token = get_session_token(api_key)
print(session_token)

import requests
from PIL import Image
from io import BytesIO
import numpy as np

def request_and_classify_images(panoIDs, api_key, session_token, output_folder):
    """
    Requests street view images for given panorama IDs, classifies vegetation, and saves B&W images.

    Parameters:
    panoIDs (list): A list of panorama IDs to process.
    api_key (str): API key for the requests.
    session_token (str): Session token for API requests.
    output_folder (str): Folder path to save the B&W images.
    """
    # Define the headings for the images
    headingArr = 360 / 6 * np.array([0, 1, 2, 3, 4, 5])  # Three headings: 0, 120, 240 degrees

    for panoID in panoIDs:
        # Fetch images and classify vegetation for each heading
        for heading in headingArr:
            URL = f"https://maps.googleapis.com/maps/api/streetview?size=400x400&pano={panoID}&heading={heading}&pitch=0&key={api_key}"

            try:
                response = requests.get(URL)
                if response.status_code == 200:
                    # Read the image content into an array
                    im = np.array(Image.open(BytesIO(response.content)))
                    # Apply vegetation classification to the image
                    bw_image = VegetationClassificationToMask(im)
                    greenPercent = VegetationClassification(im)
                    print(f'Panorama ID: {panoID}, Heading: {heading}, Green Percent: {greenPercent}')

                    # Save the B&W image to the output folder
                    bw_image_pil = Image.fromarray(bw_image)
                    bw_image_pil.save(f'{output_folder}/panoID-{panoID}-heading-{heading}.png')

                else:
                    print(f"Error fetching image for panoID {panoID}: HTTP {response.status_code}")
            except requests.RequestException as e:
                print(f"Request failed for panoID {panoID}: {e}")

from google.colab import drive
drive.mount('/content/drive')

panoIDs = ['lt1Odnbery-hPmFvvOt26A', '84Mv_QbFB_SkWYga2zqEMA', 'ixx5zBE9BvknUz2Xdi9BwA']
api_key = 'AIzaSyC6SI5E0xZd2txN1gUtGo52CYKpOlXBRSU'
output_folder = '/content/drive/MyDrive/C257 Project/Data/Street View Image VS BW Image'
request_and_classify_images(panoIDs, api_key, session_token, output_folder)

